### List
#### 介绍
- list是处理一组有序项目的数据结构
- List(列表)是Python中使用最频繁的数据类型。
- 列表可以完成大多数数据集合类的数据结构实现，它支持字符，数字，字符串甚至还可以嵌套列表、元组，字典等。
- 列表用方括号[]标示，内部元素间用逗号隔开。


#### 创建list
- 创建空列表
```
list1 = []
```

- 创建非空列表
```
list2 = [1, 'vd', 12.3, [1,2,'sd']]
```

####  访问列表
- 与字符串的索引一样，列表索引从0开始。
- 列表可以进行截取、组合等。
- 使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取列表。
```
list1 = ['physics', 'chemistry', 1997, 2000]; list2 = [1, 2, 3, 4, 5, 6, 7 ];
print "list1[0]: ", list1[0]
print "list2[1:5]: ", list2[1:5]
```

#### 更新列表
1. 直接给列表元素赋值
```
list1= ['physics', 'chemistry', 1997, 2000]
list1[2]='englist'
print(list1)
```
显示：['physics', 'chemistry', 'englist', 2000]

2. 添加元素append()
```
list1= ['physics', 'chemistry', 1997, 2000]
list1.append('new value')
print(list1)
```
显示：['physics', 'chemistry', 'englist', 2000,'new value']

##### 删除列表
3. 删除某个元素
- 使用remove()移除列表中的元素
```
list1 = ['a',1,2,'one']
list1.remove(2)
print(list1)
```
显示:['a', 1, 'one']
- 使用del语句来删除列表的的元素或整个列表
```
list1 = ['a',1,2,'one']
del list1[2]
print(list1)
```

#####  列表运算符
- +号显示添加
```
[1, 2, 3] + [4, 5, 6]   --》[1, 2, 3, 4, 5, 6]
```
- *重复 
```
['Hi!'] * 4    --》['Hi!', 'Hi!', 'Hi!', 'Hi!']
```
- 元素是否存在于列表中
3 in [1, 2, 3]   -->True

#####  列表截取
```
L = ['spam', 'Spam', 'SPAM!‘]
L[2] --->'SPAM!'
L[-2]  --->'Spam'
L[1:]--->'['Spam', 'SPAM!']
```

#### 关键函数
- list.sort( key=None, reverse=False)
  - key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。  
  - reverse -- 排序规则，reverse = True 降序， reverse = False 升序（默认）。
```
vowels = ['e', 'a', 'u', 'o', 'i']
vowels.sort()
print(vowels)    ---》显示['a', 'e', 'i', 'o', 'u'] 
```

降序
```
vowels = ['e', 'a', 'u', 'o', 'i']
vowels.sort(reverse=True)
print(vowels)    ---》显示['u', 'o', 'i', 'e', 'a']
```

对比值的使用
```
random = [(2, 2), (3, 4), (4, 1), (1, 3)]
random.sort(key=lambda x:x[1])
print(random)
```

##### list复制
引用复制
```
P1= P=[1,2,3,4,5,6,7]
print(P1)
P1.append(8)
print("修改后的p1:",P1,"&修改前的p:",P)
```

非引用复制
```
P2=P1[:]
P2.append(9)
print(P2,P)
```

#### 列表深浅拷贝
列表的内置方法copy
```
s = [[1,2],3,4]
s1 = s.copy()
print(s)      -->[[1, 2], 3, 4]
print(s1)     -->[[1, 2], 3, 4]
```
对s1修改：
```
s = [[1,2],3,4]
s1 = s.copy()    
s1[1] = 'oliver'
s1[0][1] = 'hello'
print('列表s：',s)        --》 [[1, 'hello'], 3, 4]
print('列表s1:',s1)       --》 [[1, 'hello'], 'oliver', 4]
```
使用列表内置的copy方法，是将新列表中的元素指向了与原列表相同的内存空间。但是，如果列表中嵌套了列表，拷贝后的列表中嵌套的列表元素指针，指向原列表中嵌套列表的整体地址，而不是指向嵌套列表中元素的内存地址。  
如果要完整的copy列表，就要使用到深拷贝
```
import  copy
s = [[1,2],3,4]
s2 = copy.deepcopy(s) 
s2[0][1] = 'abc'
print('列表s：',s)
print('列表s2：',s2)
```
使用copy.deepcopy（）方法来拷贝列表，修改嵌套列表中的元素，原列表不受影响。  
总结  
1、浅拷贝只能拷贝最外层，修改内层则原列表和新列表都会变化。  
2、深拷贝是指将原列表完全克隆一份新的。

#### 生成器
通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。
所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。
```
def odd(): 
    print 'step 1' yield 1
    print 'step 2' yield 3
    print 'step 3' yield 5
```